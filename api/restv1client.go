/*
 * Copyright 2023 RapidLoop, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

// This file is^H^H used to be! autogenerated.

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"strings"
	"time"
)

// RestV1Client is a client for RestV1 servers.
type RestV1Client struct {
	base    string
	client  *http.Client
	retries int
	debug   bool
}

// RestV1ClientError represents errors because of non-2xx HTTP response code.
type RestV1ClientError struct {
	code int
	msg  string
}

func newRestV1ClientError(code int) *RestV1ClientError {
	return &RestV1ClientError{
		code: code,
		msg:  fmt.Sprintf("server returned HTTP error code %d", code),
	}
}

// Code returns the HTTP response status code.
func (e *RestV1ClientError) Code() int {
	return e.code
}

// Error returns a human-readable error message.
func (e *RestV1ClientError) Error() string {
	return e.msg
}

// NewRestV1Client creates a new client to talk to the specified base URL
// and with the given timeout.
func NewRestV1Client(base string, timeout time.Duration, retries int) *RestV1Client {
	if !strings.HasSuffix(base, "/") {
		base += "/"
	}

	dialer := &net.Dialer{
		Timeout:   timeout,
		KeepAlive: 3 * time.Minute,
	}

	dial := func(network, address string) (net.Conn, error) {
		c, err := dialer.Dial(network, address)
		if err != nil {
			return c, err
		}
		if tc, ok := c.(*net.TCPConn); ok {
			tc.SetKeepAlive(true)
			tc.SetKeepAlivePeriod(3 * time.Minute)
		}
		return c, err
	}

	tr := http.DefaultTransport.(*http.Transport).Clone()
	tr.Dial = dial

	return &RestV1Client{
		base: base,
		client: &http.Client{
			Timeout:   timeout,
			Transport: tr,
		},
		retries: retries,
	}
}

// SetDebug enables/disables debug output.
func (c *RestV1Client) SetDebug(b bool) {
	c.debug = b
}

func (c *RestV1Client) dlog(f string, args ...interface{}) {
	if c.debug {
		log.Printf(f, args...)
	}
}

func (c *RestV1Client) callOnce(path string, req interface{}, resp interface{}) (retry, wait bool, err error) {
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)

	// json-encode and gzip-compress the request body
	reqBody := &bytes.Buffer{}
	gzw := gzip.NewWriter(reqBody)
	if err = json.NewEncoder(gzw).Encode(req); err != nil {
		return
	}
	gzw.Close()
	c.dlog("compressed input to %d bytes", reqBody.Len())

	// make HTTP request object
	hr, err := http.NewRequest("POST", c.base+path, reqBody)
	if err != nil {
		return
	}
	hr.Header.Set("Content-Type", "application/json")
	hr.Header.Set("Content-Encoding", "gzip")
	hr.Close = true

	// perform HTTP request
	c.dlog("starting HTTP POST")
	r, err := c.client.Do(hr)
	c.dlog("client done, err=%v, response=%v", err, r != nil)
	if r == nil && strings.HasSuffix(err.Error(), "EOF") {
		// this case needs to be handled better
		c.dlog("HTTP client returned EOF")
		err = nil
		return
	}
	if err != nil {
		retry = true
		wait = !strings.Contains(strings.ToLower(err.Error()), "timeout")
		return
	}
	if r.StatusCode == 429 {
		err = errors.New("rate limited, retry after 60 seconds")
		return
	} else if r.StatusCode == 409 {
		err = errors.New("previous store for this server is still in progress")
		return
	} else if r.StatusCode/100 == 5 {
		err = newRestV1ClientError(r.StatusCode)
		retry = true
		wait = true
		return
	} else if r.StatusCode/100 != 2 {
		err = newRestV1ClientError(r.StatusCode)
		return
	}
	if r.Body == nil {
		err = fmt.Errorf("empty body received")
		return
	}
	defer r.Body.Close()
	body, err := ioutil.ReadAll(r.Body)
	c.dlog("read body: err=%v, len=%d", err, len(body))
	if err != nil {
		return
	}

	err = json.Unmarshal(body, resp)
	return
}

func (c *RestV1Client) call(path string, req interface{}, resp interface{}) error {
	var last error
	for i := 0; i < c.retries; i++ {
		retry, wait, err := c.callOnce(path, req, resp)
		last = err
		if err == nil {
			return nil
		}
		if !retry {
			return err
		}
		if wait {
			c.dlog("waiting for %v before retrying", c.client.Timeout)
			time.Sleep(c.client.Timeout)
		}
	}
	return last
}

// Report calls RestV1.Report
func (c *RestV1Client) Report(req ReqReport) (resp RespReport, err error) {
	err = c.call("report", req, &resp)
	return
}

// ReportPgBouncer calls RestV1.ReportPgBouncer
func (c *RestV1Client) ReportPgBouncer(req ReqReportPgBouncer) (resp RespReport, err error) {
	err = c.call("reportpgbouncer", req, &resp)
	return
}
